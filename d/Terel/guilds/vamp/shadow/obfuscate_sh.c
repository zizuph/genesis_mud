/*
 * Obfuscate Shadow
 * 
 * Balance Team asked for this shadow to be created and separated from the
 * main Vampire shadow.
 *
 * Created by Petros, February 2009
 * Updated by Lilith, March 2009
 *   -removed redunant check from prior version of ability
 *   -fixed resolve task issue with result being too low or negative
 * Updated by Petros, April 2009
 *   -set correct resistance check
 *   -removed difficulty minimum for resolve task
 */
 
#include <tasks.h>     /* For difficulty and stat defines */
#include <ss_types.h>  /* For skill defines */
#include <stdproperties.h> /* For standard properties */
#include <macros.h> /* For macros */
#include <filter_funs.h> /* For easy filters */

#include "../defs.h"

inherit "/std/shadow";

#define RETEST_TIME 300 

#define MENTAL_TEST_COST 6
#define SPELL           (CORELIB_DIR + "spell")

public  mapping     Tested_livings=([ ]);

/*
 * Removed Enhanced_block functionality. February 2009.
 * Rationale:
 *  Obfuscate will be fixed so that it cannot be fail-proof. Currently,
 *  the spell uses a resolve_task to check on success/failure, hanging
 *  on to the result so that further testing is not necessary. However,
 *  a failure result can be removed by the simple act of recasting
 *  the spell which calls enhance_stalk_block() in the stalk.c part
 *  of the shadow. Doing this gives an essential 100% success rate,
 *  removing the purpose of the original call to resolve_task. Worse
 *  yet, the enhance_stock_block() calls continually raise the value
 *  for resolve_task, making it even less likely (impossible) to fail. 
mapping Enhanced_block=([ ]);
 */
 
// Prototypes
public int check_seen(object for_obj);

public int
query_obfuscate_shadow()
{
    return 1;
}

public void
remove_obfuscate_shadow()
{
    foreach (object live : FILTER_LIVE(all_inventory(environment(QSW))))
    {
        check_seen(live);
    }
      
    remove_shadow();
}

/*
 * Function name: query_top_shadow
 * Description:   Because shadows exist in layers, sometimes you need
 *                to reference functions in a shadow above you. Calling
 *                functions can fail if one doesn't call from the top
 *                shadow. this function allows one to obtain the
 *                top most shadow, giving access to all functions.
 * Returns:       object - top level shadow
 */
public object
query_top_shadow()
{
    object last_me, me;
    
    me = shadow_who;
    last_me = me;
    while (me = shadow(me, 0))
    {
        // loop through to find the top level shadow who
        last_me = me;
    }   
    
    // We return now the top level shadow
    return last_me;
}

/*
 * Function:    query_vampire_stat
 * Description: Returns what the vampire stat is. They use calculations
 *              such as sunlight and blood to determine the actual
 *              stat that should be used.
 */
public int 
query_vampire_stat()
{
    return query_top_shadow()->query_vamp_stat();
}

private void 
notify_unnoticed(object for_obj)
{
    if (!objectp(for_obj))
        return;
    if (environment(QSW)!=environment(for_obj))
        return;
    if (check_seen(for_obj))
        return;
    /*
     * Notification removed. February 2009.
     * Rationale:
     *  An undocumented feature exists which sends a useful messages to
     *  Vampires when magic resistance is being checked against them.
     *  Similarly, a message is generated by the obfuscate spell when
     *  check_seen is called against them. Player knowledge of such calls
     *  from the mudlib are inappropriate, and will be removed.
     
    QSW->catch_msg(
       QCTNAME(for_obj) + " glances in your direction but does not seem " +
       "to notice you.\n");
     */
}

public int
query_obfuscate_resistance(object player, object target)
{
    // Obfuscate Resistance is based on Air Element and Illusion
    setuid();
    seteuid(getuid());    
    return SPELL->spell_resist_illusion(player, target, 
                SS_ELEMENT_AIR, TASK_FORMIDABLE);                    
}

private void 
notify_startled(object for_obj)
{
    if (!objectp(for_obj))
        return;
    if (environment(QSW)!=environment(for_obj))
        return;
    /*
     * Notification removed. February 2009.
     * Rationale:
     *  An undocumented feature exists which sends a useful messages to
     *  Vampires when magic resistance is being checked against them.
     *  Similarly, a message is generated by the obfuscate spell when
     *  check_seen is called against them. Player knowledge of such calls
     *  from the mudlib are inappropriate, and will be removed.
     
    for_obj->catch_msg("You are startled to find " + 
        QTNAME(QSW) + " standing next to you!\n");
    QSW->catch_msg(
       QCTNAME(for_obj) + " looks surprised to see you.\n");
     */
    object tp=TP;
    set_this_player(QSW);
    for_obj->init_living();
    set_this_player(tp);
    
}

public int 
check_seen(object for_obj)
{
    int shadow_result=QSW->check_seen(for_obj);

    if (!living(for_obj))
    {
        return shadow_result;
    }
    
    if (for_obj==QSW)
    {
        return shadow_result;
    }
    
    if (for_obj->query_wiz_level())
    {
       return shadow_result;
    }
    
    if (for_obj->query_vampire())
    {
        return shadow_result;
    }
       
    if (member_array(for_obj,QSW->query_team_others())>=0)
    {
        return shadow_result;
    }

    if (member_array(for_obj,QSW->query_invited())>=0)
    {
        return shadow_result;
    }

    // This check was in place when partial invisibility was available.
    // As it is no longer possible to be partially invisible in combat, 
    // this check no longer belongs. - Lilith March 2009
    /*
    if (member_array(QSW,
        for_obj->query_combat_object()->cb_query_enemy(-1))>=0)
    {
        return shadow_result;
    }
    */
    
    // Added February 2009. A target should be granted a resistance
    // check against the invasion in their mind. Up until this
    // point, no vampire spells have working resistance, and thus
    // always succeeds against opponents.
    // Changed April 2009: Lilith requested illusion resistance
    //                     to be checked instead of AIR. Also,
    //                     old implementation did not properly
    //                     check combined resistance. Making
    //                     call to spell_resist_illusion to
    //                     handle both issues.
    if (query_obfuscate_resistance(shadow_who, for_obj) > random(100))
    {
        return shadow_result;
    }
    
    int occ_stat = query_vampire_stat() / 2;
    
    int * prior_result=Tested_livings[OB_NAME(for_obj)];
    
    if (sizeof(prior_result) && prior_result[0]>time()-RETEST_TIME)
    {
        if (prior_result[1] > occ_stat)
        {
            return shadow_result;
        }
        return 0;
    }
    
    int difficulty = TASK_EASY;
    
    if (!for_obj->query_humanoid())
    {
        difficulty = TASK_SIMPLE;
    }
    
    // Changed April 2009:
    // According to Cotillion, a single level of LIVE_I_SEE_INVIS
    // should allow one to see all invis, including obfuscate. Given
    // that I think obfuscate is a very special ability, we will
    // make it still based on the resolve_task.
    difficulty -= (max(0, for_obj->query_prop(LIVE_I_SEE_INVIS)) * 50);
    
    int new_result=1000;
    
    new_result=for_obj->resolve_task(difficulty,
        // Changed February 2009. A target's awareness and stats
        // are pitted against the vampires illusion and stats.
        // It doesn't make sense to compare a target's illusion
        // skill and the vampire's awareness.
        ({ SS_AWARENESS, TS_INT, TS_WIS }),
        QSW,
        ({ SS_FORM_ILLUSION, TS_INT, TS_WIS }));
    if (new_result > 0)
    {
        if (QSW->query_mana()<MENTAL_TEST_COST)
        {
            new_result=1000;
        }
        else
        {
            QSW->add_mana(-MENTAL_TEST_COST);
        }
    }
    
    if (shadow_result && new_result>occ_stat && sizeof(prior_result) &&
        prior_result[1]<=occ_stat)
    {
        m_delkey(Tested_livings,OB_NAME(for_obj));
        notify_startled(for_obj);
    }

    if (shadow_result && new_result<=occ_stat && 
        (!sizeof(prior_result) || prior_result[1]>occ_stat))
    {
        set_alarm(2.0+rnd()*4.0,0.0,&notify_unnoticed(for_obj));
    }
    
    Tested_livings+=([ OB_NAME(for_obj) :({ time(), new_result }) ]);

    if (new_result > occ_stat)
        {
            return shadow_result;
        }
    
    return 0;
}

public int 
start_obfuscate()
{
    // This does an initial check through all the livings
    // to fill up the Tested_livings.
    foreach(object live : FILTER_LIVE(all_inventory(environment(QSW))))
    {
        check_seen(live);
    }

    return 1;
}
