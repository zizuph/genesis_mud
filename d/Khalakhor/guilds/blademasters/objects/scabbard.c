#pragma strict_types

#include <stdproperties.h>
#include <wa_types.h>
#include <macros.h>
#include <composite.h>
#include <language.h>
#include "/d/Khalakhor/sys/defs.h"

inherit "/std/container";
inherit "/lib/wearable_item";

string extra_adj;

public string
extra_long()
{
    if (!worn)
        return "\n";

    else
        return "You currently have it slung" +
            wear_how(worn_on_part) + ".\n";
}

public nomask void
create_container()
{
    set_name("scabbard");
    set_adj(({"leather","shoulder"}));
    set_long("This leather shoulder scabbard is little more than " +
        "a wide, black leather belt that's had a hard leather scabbard " +
        "riveted to it lengthwise. When worn over a shoulder, it will " +
        "comfortably carry even the largest of swords strapped across " +
        "the wearer's back, with easy access for a draw from over " +
        "the shoulder. @@extra_long@@");

    config_wearable_item(A_ANY_SHOULDER, 2, 2, TO);

    add_prop(CONT_I_WEIGHT, 1000);
    add_prop(CONT_I_MAX_WEIGHT, 10000);
    add_prop(CONT_I_VOLUME, 1000);
    add_prop(CONT_I_MAX_VOLUME, 10000);
    add_prop(CONT_I_TRANSP, 1);
    add_prop(CONT_I_RIGID, 0);
}

public void
leave_env(object from, object to)
{
    ::leave_env(from, to);
    wearable_item_leave_env(from, to);
}

public int
check_scabbards(object ob)
{
    if (MASTER_OB(ob) == MASTER)
        return 1;
    return 0;
}

public mixed
do_wear_item()
{
    return ::do_wear_item();
}

/*
 * Function name: check_slot
 * Description  : Called when wearing this object to see if it will
 *                fit over existing layers of wearable items. Masked
 *                here to prevent people from wearing two scabbards over
 *                the same shoulder (which is otherwise possible because
 *                they are 'loose' enough to fit over another scabbard.)
 * Arguments    : slot - The armour slot to wear the object in.
 * Returns      : If a string, the reason why we couldn't wear it. Otherwise,
 *                returns a 1 to show we can wear it.
 */
public mixed
check_slot(int slot)
{
    int i, layers, flag;
    object *worn_arr;
    mixed resp;

  /* First call back and see if there's a default reason players */
  /* can't wear this object. */
    resp = ::check_slot(slot);

  /* If 'resp' is a string, it's a failure message generated by */
  /* the default routine. */
    if (stringp(resp))
        return resp;

  /* Now make sure the player isn't already wearing a scabbard */
  /* over that shoulder. Do that by seeing if the master object */
  /* if anything worn in that slot is the same as the master */
  /* for this object. */
    worn_arr = TP->query_clothing(slot);

    if (!sizeof(worn_arr))
        return 1;

    worn_arr = filter(worn_arr, check_scabbards);

    if (sizeof(worn_arr))
    {
        return "You are already wearing " + COMPOSITE_DEAD(worn_arr) +
            wear_how(slot) + ", you cannot wear another one " +
            "over it.\n";
    }

    return 1;
}

/*
 * Function name: wear_how
 * Description:   Generate the string that is shown when the armour is worn.
 *                Masked here to change the " on his right shoulder" type
 *                description to " over his right shoulder". Purely
 *                cosmetic.
 * Arguments:     location: the location(s) covered by the armour
 */
public string
wear_how(int location)
{
    string how, pos;

    if (this_player() == wearer)
        pos = "your";
    else
        pos = wearer->query_possessive();

    if (location == A_R_SHOULDER)
        return " over " + pos + " right shoulder";
    else if (location == A_L_SHOULDER)
        return " over " + pos + " left shoulder";
    else
        return ::wear_how(location);
}

public int
wear(object ob)
{
    if (ob != TO)
        return 0;

    write("You pull the strap on the " + short() + " over your " +
        "head and settle it across your back" + 
        wear_how(worn_on_part) + ".\n");
    say(QCTNAME(TP) + " pull the strap on " + LANG_ADDART(short()) +
        " over " + HIS_HER(TP) + " head and settles across " + HIS_HER(TP) +
        " back" + wear_how(worn_on_part) + ".\n");
    if (worn_on_part == A_R_SHOULDER)
        extra_adj = "right";
    else
        extra_adj = "left";
    add_adj(extra_adj);
    return 1;
}

public int
remove(object ob)
{
    if (ob != TO)
        return 0;

    remove_adj(extra_adj);
    return 0;
}

public void
describe_contents(object who, object *obarr)
{
    if (sizeof(obarr) > 0)
    {
        who->catch_tell(capitalize(COMPOSITE_DEAD(obarr)) + 
            " rests easily in the " + short() + ".\n");
    }
    else
    {
        who->catch_tell("The " + short() + " is empty.\n");
    }
}

/* Function name: appraise_object (MASK)
 * Description  : Appraise the object.
 * Arguments    : int num - The appraise number, randomized.
 * Returns      : n/a
 */

public void
appraise_object(int num)
{
    ::appraise_object(num);

    appraise_wearable_item();
}
