/*
 * This set of routines takes care of selecting unique descriptions for new
 * torques.  A torque description is composed of a certain number of
 * adjectives taken from an approved list.  
 *
 * This routine is difficult to describe, so I think an example is the best
 * way to show how it basically works.
 *
 * There are two files that are used to store our data.  The first lists the
 * set of approved adjectives. Here is a sample:
 *
 *     adjective 1:  ugly, pretty, plain
 *     adjective 2:  blue, red, green
 *     adjective 3:  gold, silver, lead, iron
 *
 * We can choose one adjective from each list to create a description ("ugly
 * blue iron", "pretty red silver", "plain green gold", etc.).  The second
 * file we use lists alphabetically all of the descriptions that have been
 * created.  Here is a sample:
 *
 *     plain blue lead
 *     plain red silver
 *     pretty blue gold
 *     pretty green gold
 *     pretty red lead
 *     ugly blue gold
 *     ugly blue iron
 *     ugly blue lead
 *     ugly blue silver
 *     ugly green gold
 *     ugly red gold
 *
 * For our example, we wish to construct our torque description from a set of
 * three adjectives.
 *
 * We first attempt to select a unique first adjective. Our routine reads
 * through the second file, finding all the adjectives which have been used in
 * the first position: "plain", "pretty", and "ugly".  These adjectives are
 * removed from our list of available first-position adjectives.  This leaves us
 * with no adjectives that have not been used before, and so we choose randomly
 * from the complete list of available first adjectives.  Assume the adjective
 * "pretty" is selected.
 *
 * We now attempt to select a unique second adjective.  Our routine reads
 * through the second file again, this time only finding adjectives which have
 * been used in the second position.  This time, though, we are only interested
 * in those descriptions which start with "pretty".  We find three such
 * descriptions, and the second adjectives in those are "red", "blue", and
 * "green".  These adjectives are removed from our list of available
 * second-position adjectives, and, again, we are left with no adjectives that
 * have not been used before.  We select randomly from the complete list of
 * second adjectives.  Assume that "red" is selected.
 *
 * We now attempt to select a unique third adjective.  Our routine repeats,
 * this time only examining descriptions that start with "pretty red".  We find
 * one such description, and the third adjective in that description is "lead".
 * This adjective is removed from our list of available third-position
 * adjectives, and this time we are left with three available adjectives:
 * "gold", "silver", and "iron".  Choosing any of these three adjectives
 * produces a unique description--"pretty red gold", "pretty red silver",
 * "pretty red iron".
 *
 * While this routine will do pretty well with a large selection of adjectives,
 * it is not perfect, and it can generate duplicate descriptions even though
 * there might be some unused combination of adjectives.  You can see how this
 * might happen by imagining a scenario involving the data above in which the
 * adjective "ugly" is first selected, followed by "blue".  The third
 * selection can only be one of "gold", "lead", "iron", or "silver", all of
 * which produce a duplicate description.  While it's possible to create a
 * routine which guarantees that all combinations are exhausted before any
 * duplicates are produced, it would be much too complicated and inefficient
 * to include here.  Thankfully, a large set of adjectives and efforts to
 * reclaim unused descriptions (primarily from purged players) can help to
 * make duplicates extremely rare.
 */
#pragma no_clone
#pragma no_inherit
#pragma no_shadow

#include "torque.h"

#define USED_TORQUE_DESCS (TORQUE_LOG + "used_torque_descs")
#define TORQUE_DESCS     (TORQUE_LOG + "torque_descs")

#define READ_LINES 250

int td_read_position,
    td_start_position,
    td_processing = 0;

string *td_chosen_descs,
       *td_desc_format;
string  td_owner;
mapping td_used_adjs,
        td_available_descs;

public void mkdesc2();
public void mkdesc3();
public void mkdesc4();
public mapping read_adj_file();

/*
 * Function name: mkdesc
 * Description:   Create a (hopefully) unique torque description and assign it
 *                to the given player's torque.  Note that the description is
 *                generated in parts over time.  It should not be assumed that
 *                a description has been generated by the time that this
 *                function returns.
 * Arguments:     1. (string)   The format string for the torque description.
 *                              It is comprised of random adjective selectors
 *                              (indicated by a $) and preselected adjectives
 *                              (any other words).  Random adjective selectors
 *                              will be replaced by adjectives selected at
 *                              random from the list of predefined adjectives,
 *                              according to category ("$GENERAL" selects an
 *                              adjective from the GENERAL category).
 *                              A format string such as "$GENERAL old $METAL"
 *                              might yield a final description such as
 *                              "lovely old gold", "lovely" being a GENERAL
 *                              category adjective, "old" being a preselected
 *                              adjective, and "gold" being a METAL category
 *                              adjective.
 *                2. (string)   The optional name of the owner.  If specified,
 *                              the generated description will be registered
 *                              as being owned by the given player.
 * Returns:       true if generation of the description has commenced
 *                false if description generation could not be started
 */
public varargs int
mkdesc(string desc_format, string owner = 0)
{
    if (td_processing)
    {
        return 0;
    } 

    setuid();
    seteuid(getuid());

    td_processing = 1;
    td_owner = owner;
    td_read_position = 1;
    td_start_position = 0;
    td_available_descs = read_adj_file();

    td_desc_format = explode(desc_format, " ") - ({ "" });

    td_chosen_descs = ({});
    td_used_adjs = ([]);

    set_alarm(0.0, 0.0, &mkdesc2());

    return 1;
}

/*
 * Function name: read_adj_file
 * Description:   Read the list of available adjectives, and store it in a
 *                more useful data structure.
 * Returns:       A map of adjective category names to adjectives.
 */
public mapping
read_adj_file()
{
    string str;
    int i;
    string *lines, *words;
    mapping adjs = ([]);

    setuid();
    seteuid(getuid());

    str = read_file(TORQUE_DESCS);

    if (!strlen(str))
    {
        return adjs;
    }

    lines = explode(str, "\n") - ({ "" });
    for (i = 0; i < sizeof(lines); i++)
    {
        if (lines[i][0] == '#')
        {
            // This line contains a comment, so just skip it
            continue;
        }

        words = explode(lines[i], " ") - ({ "" });

        if (sizeof(words) > 1)
        {
            adjs[words[0]] = words[1..];
        }
    }

    return adjs;
}

/*
 * Function name: mkdesc2
 * Description:   Reads through the list of used torque descriptions and
 *                composes a list of adjectives that have already been
 *                used.  When this list is completed, it initiates the
 *                next part of the routine.  Note that this function is
 *                written so that it reads the list in small chunks,
 *                possibly invoking itself several times through an alarm.
 *                This is done because this part of the routine can be
 *                very slow, and we want to avoid eval cost errors from
 *                the gamedriver.  Breaking up the processing into smaller
 *                tasks should avoid that problem.  Unfortunately, it also
 *                complicates the code considerably.
 */
public void
mkdesc2()
{
    string file, word, pre;
    string *lines;
    int i;

    file = read_file(USED_TORQUE_DESCS, td_read_position, READ_LINES);
    td_read_position += READ_LINES;

    if (strlen(file))
    {
        lines = explode(file, "\n");
    
        pre = implode(td_chosen_descs, " ");
    
        // If the last line comes alphabetically before the description we're
        // looking for, we know we haven't gone far enough, and there's no
        // reason to search through this chunk of lines.  We just skip to the
        // next chunk.
        if (lines[sizeof(lines) - 1][..(strlen(pre) - 1)] < pre)
        {
            set_alarm(0.0, 0.0, &mkdesc2());
            return;
        }
    
        // Search for lines that match the adjectives we've already chosen
        for (i = 0; i < sizeof(lines); i++)
        {    
            if (!strlen(pre) || (lines[i][..(strlen(pre) - 1)] == pre))
            {
                // Keep track of the position of the first matching line.  When
                // we're looking for the next set of adjectives, we'll start
                // reading at that line, saving ourselves from searching
                // previous lines, which we know won't match.
                if (td_start_position && (i < td_start_position))
                {
                    td_start_position = i + 1;
                }
    
                // strip off the matching, leading adjectives and make note
                // of the next adjective that's used.  Later on, we'll use
                // this list of "used" adjectives to make sure we select a
                // new adjective if possible.
                //
                // Note that I use a mapping here when it probably seems more
                // logical to use an array.  I do this because I don't want
                // duplicate adjectives in my list.  Avoiding duplicates in
                // an array means searching the array every time I add a new
                // adjective, which would be very ineffecient.  Storing each
                // adjective as an index in a mapping means that duplicates
                // are efficiently overwritten.
                word = (explode(lines[i][strlen(pre)..], " ") - ({ "" }))[0];
                td_used_adjs[word] = 0;
            }
        }
    
        // It's possible that a set of matching descriptions falls across two 
        // chunks.  If the last line of this chunk is a match, we go on and
        // read the next chunk to look for more matches.
        if (!strlen(pre) || 
            (lines[sizeof(lines) - 1][..(strlen(pre) - 1)] == pre))
        {
            set_alarm(0.0, 0.0, &mkdesc2());
            return;
        }
    }

    set_alarm(0.0, 0.0, &mkdesc3());
}

public void
mkdesc3()
{
    int this_adj;
    int i;
    string adj_selector;
    string *unused_adjs, *avail_adjs;

    this_adj = sizeof(td_chosen_descs);

    if (this_adj == sizeof(td_desc_format))
    {
        set_alarm(0.0, 0.0, &mkdesc4());
        return;
    }

    adj_selector = td_desc_format[this_adj];
    if (adj_selector[0] != '$')
    {
        // No random adjective is desired.  Use the supplied one.
        td_chosen_descs += ({ adj_selector });
    }
    else
    {
        adj_selector = adj_selector[1..];
        avail_adjs = td_available_descs[adj_selector];

        if (avail_adjs == 0)
        {
            td_chosen_descs += ({ "" });
        }
        else
        {
            // Take the used adjectives out of our list of available adjectives
            unused_adjs = avail_adjs - (mixed *)m_indices(td_used_adjs);
    
            if (sizeof(unused_adjs))
            {
                // If there are any unused adjectives available, we can choose one
                // of those and have a unique description.  The rest of the adjectives
                // can be chosen randomly without needing to compare them to any more
                // existing descriptions.
        
                td_chosen_descs += ({ unused_adjs[random(sizeof(unused_adjs))] });
        
                for (++this_adj; this_adj < sizeof(td_desc_format); this_adj++)
                {
                    adj_selector = td_desc_format[this_adj];
                    if (adj_selector[0] != '$')
                    {
                        td_chosen_descs += ({ td_desc_format[this_adj] });
                    }
                    else
                    {
                        adj_selector = adj_selector[1..];
                        avail_adjs = td_available_descs[adj_selector];

                        if (avail_adjs == 0)
                        {
                            td_chosen_descs += ({ "" });
                        }
                        else
                        {
                            td_chosen_descs += 
                                ({ avail_adjs[random(sizeof(avail_adjs))] });
                        }
                    }
                }
        
                set_alarm(0.0, 0.0, &mkdesc4());
                return;
            }
            else 
            {
                // If there aren't any unused adjectives available, we just choose a
                // used one at random and try to make a unique description with the
                // next adjective.
        
                td_chosen_descs += 
                    ({ avail_adjs[random(sizeof(avail_adjs))] });
            }
        }
    }

    td_used_adjs = ([]);
    td_read_position = td_start_position;
    td_start_position = 0;
    set_alarm(0.0, 0.0, &mkdesc2());
    return;
}

public void
mkdesc4()
{
    string desc, txt, file;
    string *lines;

    td_read_position = (td_start_position ? td_start_position : 1);

    desc = implode(td_chosen_descs - ({ "" }), " ");

    // Find the chunk of lines where the description fits alphabetically
    do
    {
        file = read_file(USED_TORQUE_DESCS, td_read_position, READ_LINES);
        td_read_position += READ_LINES;

        if (!strlen(file))
        {
            lines = ({});
            break;
        }

        lines = explode(file, "\n") - ({ "" });
    }
    while (lines[sizeof(lines) - 1] < desc);

    // Add the new description to the chunk of lines
    lines += ({ desc });
    // Sort the chunk alphabetically
    lines = sort_array(lines);

    // I take a somewhat roundabout way to write out the new data.  The point
    // here is to try not to rewrite any data unless we have to.

    // First, read in all of the lines from the end of the last chunk on.
    txt = read_file(USED_TORQUE_DESCS, td_read_position);

    // Now, write the new description at the end.  We'll actually end up
    // overwriting this later, but we don't care.  We're only doing this so
    // that the file is length of the file to accomodate the new description
    // when it's put in its proper position (write_bytes() cannot append).
    write_file(USED_TORQUE_DESCS, desc + "\n");

    // Prepend the alphabetized chunk of lines (with our new description
    // included) to the tail of the file.
    txt = implode(lines, "\n") + "\n" + (strlen(txt) ? txt : "");

    // Write it all out, leaving the head of the file unaltered.
    write_bytes(USED_TORQUE_DESCS, -strlen(txt), txt);

    if (td_owner)
    {
        TORQUE_MANAGER->set_torque_desc(td_owner, desc);
    }

    td_processing = 0;
}
