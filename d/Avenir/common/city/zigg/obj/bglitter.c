// Body Glitter ("bglitter.c")
// creator(s):   Zielia 2006
// last update:
// purpose:      Subloc object generated by ~glotion.c.
// note:
// bug(s):
// to-do:
#pragma strict_types

inherit "/std/object";
inherit "/lib/commands";

#include <macros.h>
#include <stdproperties.h>
#include <composite.h>
#include <cmdparse.h>
#include <adverbs.h>
#include "zigg.h"

#define SUBLOC "_glittery_skin_"
#define SKIN_SUBLOC "having_skincolour_subloc"


private static object skin_sub;
private static string *glitters = ({});

public void
create_object(void)
{
    setuid();
    seteuid(getuid());

    set_no_show();
    set_name(({"body::glitter", "glitter"}));

    add_prop(OBJ_I_NO_DROP, 1);

}

public mixed
query_glitters(void)	{ return glitters; }

public void
set_glitter_color(string str)
{
    if (!IN_ARRAY(str, glitters))
	glitters += ({ str });
}

public string
show_subloc(string subloc, object carrier, object for_obj)
{
    string str;
    string skin;
    string color;

    if (carrier->query_prop(TEMP_SUBLOC_SHOW_ONLY_THINGS))
	return "";

    if (sizeof(glitters) > 3)
	color = one_of_list(glitters + ({"rainbow"}));
    else
	color = COMPOSITE_WORDS(glitters);

    if (!present("colourob", carrier))
    {
	if (for_obj == carrier)
	{
	    str = "Your soft skin shimmers with "+ color +" glitter.\n";
	}

	else
	{
	    str = capitalize(HIS(carrier)) +" soft skin shimmers with "+
	    color +" glitter.\n";
	}
    }
    else
    {
	skin = present("colourob", carrier)->return_colour_desc();

	if (for_obj == carrier)
	{
	    str = "Your "+ skin +" skin is dusted with "+ color +" glitter.\n";
	}
	else
	{
	    str = capitalize(HIS(carrier))+" "+ skin +" skin is dusted "+
	    "with "+ color +" glitter.\n";
	}
    }

    return str;
}

public int
glitter_tell(void)
{
    string color;
    object carrier = environment(TO);
    object room = environment(carrier);

    if (sizeof(glitters) > 3)
	color = one_of_list(glitters + ({"rainbow"}));
    else
	color = one_of_list(glitters);

    if (room->query_prop(ROOM_I_LIGHT) > 0)
    {
	tell_room(room, QCTPNAME(carrier) +" skin shimmers softly as "+
	  "the light dances over "+ HIS(carrier) +" "+ color
	  +" glitter.\n", ({carrier}), TO);

	tell_object(carrier,"Your skin shimmers softly as "+
	  "the light dances over the "+ color +" glitter.\n");

	return 1;
    }

    return 0;
}

public void
enter_env(object to, object from)
{
    ::enter_env(to, from);

    if (!IS_CLONE)
	return;

    float count = itof((random(10) * 60) + 600);

    if (present("colourob", to))
    {
	skin_sub = to->query_subloc_obj(SKIN_SUBLOC);
	to->remove_subloc(SKIN_SUBLOC);
    }

    to->add_subloc(SUBLOC, TO);
    set_alarm(60.0, count , &glitter_tell());
}

public void
remove_object(void)
{
    if (IS_CLONE)
    {
	if (present("colourob", ENV()))
	    ENV()->add_subloc(SKIN_SUBLOC, skin_sub);

	ENV()->remove_subloc(SUBLOC);
    }

    ::remove_object();
}

public int
do_remove(string str)
{
    set_alarm(0.0, 0.0, remove_object);
    return 1;
}

public nomask string
query_recover(void)	{ return 0; }
