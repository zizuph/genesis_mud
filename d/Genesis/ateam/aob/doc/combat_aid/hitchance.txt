.------.---------.---------.--------.--------.--------.--------.--------.--------.--------.--------.--------.--------.--------.
|   Def>       0 |      20 |     40 |     60 |     80 |    100 |    120 |    140 |    160 |    180 |    200 |    250 |    300 |
| Hit  |         |         |        |        |        |        |        |        |        |        |        |        |        |
+--V---+---------+---------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
|  10  | 100.00% |  99.19% | 90.75% | 80.75% | 70.75% | 60.75% | 50.75% | 40.75% | 30.75% | 20.75% | 10.75% | 08.60% | 07.16% |
|  15  | 100.00% |  99.82% | 95.38% | 85.75% | 75.75% | 65.75% | 55.75% | 45.75% | 35.75% | 25.75% | 15.75% | 12.60% | 10.50% |
|  20  | 100.00% |  99.93% | 98.06% | 90.62% | 80.75% | 70.75% | 60.75% | 50.75% | 40.75% | 30.75% | 20.75% | 16.60% | 13.83% |
|  25  | 100.00% |  99.96% | 99.13% | 94.51% | 85.69% | 75.75% | 65.75% | 55.75% | 45.75% | 35.75% | 25.75% | 20.60% | 17.16% |
|  30  | 100.00% |  99.98% | 99.56% | 96.91% | 90.12% | 80.71% | 70.75% | 60.75% | 50.75% | 40.75% | 30.75% | 24.60% | 20.50% |
|  35  | 100.00% |  99.98% | 99.74% | 98.21% | 93.50% | 85.39% | 75.72% | 65.75% | 55.75% | 45.75% | 35.75% | 28.60% | 23.83% |
|  40  | 100.00% |  99.99% | 99.83% | 98.91% | 95.76% | 89.37% | 80.52% | 70.73% | 60.75% | 50.75% | 40.75% | 32.60% | 27.16% |
|  45  | 100.00% |  99.99% | 99.89% | 99.29% | 97.20% | 92.42% | 84.85% | 75.59% | 65.73% | 55.75% | 45.75% | 36.60% | 30.50% |
|  50  | 100.00% |  99.99% | 99.92% | 99.51% | 98.09% | 94.61% | 88.48% | 80.14% | 70.64% | 60.74% | 50.75% | 40.60% | 33.83% |
|  55  | 100.00% |  99.99% | 99.93% | 99.65% | 98.66% | 96.13% | 91.32% | 84.15% | 75.31% | 65.66% | 55.74% | 44.60% | 37.16% |
|  60  | 100.00% |  99.99% | 99.95% | 99.74% | 99.03% | 97.18% | 93.46% | 87.50% | 79.59% | 70.43% | 60.68% | 48.60% | 40.50% |
|  65  | 100.00% |  99.99% | 99.96% | 99.80% | 99.27% | 97.90% | 95.04% | 90.20% | 83.33% | 74.88% | 65.50% | 52.59% | 43.83% |
|  70  | 100.00% |  99.99% | 99.96% | 99.84% | 99.44% | 98.40% | 96.20% | 92.31% | 86.49% | 78.91% | 70.08% | 56.58% | 47.16% |
|  75  | 100.00% |  99.99% | 99.97% | 99.87% | 99.56% | 98.76% | 97.05% | 93.94% | 89.07% | 82.43% | 74.32% | 60.53% | 50.49% |
|  80  | 100.00% |  99.99% | 99.97% | 99.89% | 99.64% | 99.02% | 97.68% | 95.18% | 91.16% | 85.43% | 78.14% | 64.40% | 53.82% |
|  85  | 100.00% |  99.99% | 99.97% | 99.90% | 99.70% | 99.21% | 98.14% | 96.14% | 92.82% | 87.94% | 81.48% | 68.14% | 57.14% |
|  90  | 100.00% |  99.99% | 99.98% | 99.92% | 99.75% | 99.35% | 98.49% | 96.87% | 94.14% | 90.01% | 84.36% | 71.69% | 60.43% |
|  95  | 100.00% | 100.00% | 99.98% | 99.93% | 99.79% | 99.46% | 98.76% | 97.44% | 95.18% | 91.70% | 86.81% | 74.99% | 63.66% |
| 100  | 100.00% | 100.00% | 99.98% | 99.93% | 99.82% | 99.54% | 98.97% | 97.88% | 96.01% | 93.07% | 88.86% | 78.01% | 66.82% |
| 105  | 100.00% | 100.00% | 99.98% | 99.94% | 99.84% | 99.61% | 99.13% | 98.23% | 96.67% | 94.19% | 90.57% | 80.74% | 69.85% |
| 110  | 100.00% | 100.00% | 99.98% | 99.95% | 99.86% | 99.66% | 99.26% | 98.50% | 97.19% | 95.10% | 91.99% | 83.16% | 72.73% |
'------'---------'---------'--------'--------'--------'--------'--------'--------'--------'--------'--------'--------'--------'



/*
 * Normalize offensive / defensive values
 *
 */
static nomask int
fixnorm(int offence, int defence)
{
   if (offence + defence == 0)
       return 0;

   return ((100 * offence) / (offence + defence)) - 50;
}

/*
 * Function name: cb_update_tohit_val
 * Description:   Update the tohit value for some object. Changing ones
 *                encumberance while fighting will not have any effect
 *                unless this function is called, but I think it's worth
 *                it since we save cpu.
 * Arguments:     ob - The object we shall try to hit
 *                weight - If the formula should be weighted any way.
 */
varargs void
cb_update_tohit_val(object ob, int weight)
{
    tohit_val = 2 * fixnorm(me->query_stat(SS_DEX), ob->query_stat(SS_DEX)) -
        (((me->query_encumberance_weight() +
              me->query_encumberance_volume()) -
            (ob->query_encumberance_weight() +
                ob->query_encumberance_volume())) / 4);
    tohit_val += weight + tohit_mod;
}

/*
 * Function name: cb_tohit
 * Description:   Decide if we hit our victim or not. This should depend
 *                on wchit and skill/stat differences me/victim
 * Arguments:     aid:   The attack id
 *                wchit: Weapon class 'to hit'
 *                vic:   The intended victim
 * Returns:       True if hit, otherwise a negative value indicating how much
 *                we failed.
 */
public int
cb_tohit(int aid, int wchit, object vic)
{
    int tmp, whit;
    
    /*
     * Four factors are normalized (-50, 50) in the 'to-hit'.
     * 1 - Weapon class 'to hit' <-> Defensive skill
     * 2 - Weight
     * 3 - Volume
     * 4 - Dexterity
     * These are weighted with the factors (4, 1, 1, 2)
     */

    if (sizeof(filter(vic->query_weapon(-1), objectp)))
    {
        tmp = (int) vic->query_skill(SS_PARRY);
    }
    else
    {
        /* Let the encumberance of the victim lower the effectiveness of
         * unarmed combat until 50% when fully encumbered.
         */
        tmp = max(min(vic->query_encumberance_weight(), 100), 0);
        tmp = ((200 - tmp) * vic->query_skill(SS_UNARM_COMBAT)) / 200;
    }

    tmp += vic->query_skill(SS_DEFENSE);

    /*
     * Is it dark or opponent invis? Then how well do we fight?
     */

    if (!CAN_SEE_IN_ROOM(me) ||
        (vic->query_prop(OBJ_I_INVIS) > me->query_prop(LIVE_I_SEE_INVIS)))
    {
        wchit = me->query_skill(SS_BLIND_COMBAT) * wchit / 100;
    }
    if (!CAN_SEE_IN_ROOM(vic) ||
        (me->query_prop(OBJ_I_INVIS) > vic->query_prop(LIVE_I_SEE_INVIS)))
    {
        tmp = vic->query_skill(SS_BLIND_COMBAT) * tmp / 100;
    }

    whit = 4 * fixnorm(random(wchit) + random(wchit) + 
                       random(wchit) + random(wchit), random(tmp));
    
    cb_update_tohit_val(vic);
    
    whit += tohit_val;

    if (whit > 0)
        return 1;
    else
        return whit - 1;
}


/*
 *  Below are functions to calculate the hit chance.
 *
 *  - Carnak
 */
public float
pi()
{
    return 3.14159265358979324;
}
//Uniform pdf from a to b.
public varargs float
unifpdf(int x, int a = 0, int b = 1)
{
    if (x <= a)
        return 0.0;
    
    if (a <= x && x <= b)
        return 1.0 / itof(b - a);

    return 1.0;
}

public float
erf(float x)
{
    float   t, y, sign,
    //Constants
            a1 =  0.254829592,
            a2 = -0.284496736,
            a3 =  1.421413741,
            a4 = -1.453152027,
            a5 =  1.061405429,
            p  =  0.3275911;
 
    //Change sign based on positive or negative x
    sign = 1.0;
    if (x < 0.0)
        sign = -1.0;
    
    x = abs(x);
 
    t = 1.0 / (1.0 + p * x);
    y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-x* x);
 
    return sign * y;
}

public float
normcdf(int x, float m, float s)
{
    return 0.5 * (1.0 + erf((itof(x) - m) / (s * sqrt(2.0))));
}

public varargs float
process_hit(int hit = 40, int def = 200)
{
    int     value;
    float   mean, stdev, miss = 0.0;

    // Linear summation of hit to find mean. EX: 1+2+3+4+5+6+7+8+9...
    for (int i = 0; i <= hit; i++)
        value += i;
    
    // Multiply by dice number (four in this case)
    mean = 4.0 * itof(value) / itof(hit);

    // Find the standard deviation for 4 (hit)-sided die.
    stdev = sqrt(4.0 * (pow(itof(hit), 2.0) - 1.0) / 12.0);
    
    float *test = allocate((def / 20) + 1);
    // Sum the numbers modified by uniform pdf
    for (int i = 0; i <= def; i++)
    {
        miss += normcdf(i, mean, stdev) * unifpdf(i, 0, def);
        
        if (!(i % 20))
            test[i / 20] = 100.0 - (miss / 0.01);
    }
    return 100.0 - (miss / 0.01);
}